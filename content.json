{"meta":{"title":"Json","subtitle":"My Blog","description":"","author":"Json","url":"https://tianwenju.github.io","root":"/"},"posts":[{"tags":[{"name":"React","slug":"React","permalink":"https://tianwenju.github.io/tags/React/"}],"title":"React-SSR(同构渲染)","date":"2020/10/19","text":"SSR介绍Server Slide Rendering 服务端渲染 为什么使用服务器端渲染(SSR)？ 更好的搜索引擎优化（Search-Engine-Optimization，SEO） 大部分网站都希望自己能够出现在搜索引擎的搜索页前列，这个前提就是网页内容要能够被搜索引擎的爬虫正确抓取到。虽然 Google 这样的搜索引擎已经可以检索浏览器端渲染的网页，但毕竟不是全部搜索引擎都能做到，如果搜索引擎的爬虫只能拿到服务器端渲染的内容，完全浏览器端渲染就行不通了 可以缩短“第一有意义渲染时间”（First-Meaningful-Paint-Time）解决首屏白屏问题 如果完全依赖于浏览器端渲染，那么服务器端返回的 HTML 就是一个空荡荡的框架和对 JavaScript 的应用，然后浏览器下载 JavaScript，再根据 JavaScript 中的 AJAX 调用获取服务器端数据，再渲染出 DOM 来填充网页内容，总共需要三个 HTTP 或 HTTPS 请求。 如果使用服务器端渲染，第一个 HTTP/HTTPS 请求返回的 HTML 里就包含可以渲染的内容了，这样用户第一时间就会感觉到“有东西画出来了”，这样的感知性能更好。核心原理(基于React)如下图： 服务端直接给出Html import express from \"express\";import React from \"react\";import { renderToString } from \"react-dom/server\";import App from \"../client/app\";const app = new express();app.use(express.static(\"public\"));app.get(\"/\", (req, res) => { const App = renderToString(); res.send(` hello world ${App} `);}); import React from \"react\";const handleClick = () => { alert(\"click\");};function App() { return hello ssr ;}export default App; 浏览器访问返回的结构 hello world hello ssr 此种情况下,并没有完成事件绑定呢？接下来就要用到如下 同构渲染（混合渲染） 同构指的是一套代码在服务端和客户端运行，服务端输出html结构，数据，js，客户端接管页面进行补充渲染，填充数据，绑定事件等~ 一句话：数据和Html骨架有服务端给出,客户端补充渲染。 核心代码(server)import App from \"../client/app\";const app = new express();app.use(express.static(\"public\"));function Content() { return this is content;}app.get(\"/\", (req, res) => { const root = renderToString(); res.send(` hello world ${root} `);}); index.js(client)import React from 'react';import { hydrate } from 'react-dom'hydrate(,document.getElementById(\"root\")) import React from \"react\";const handleClick = () => { alert(\"click\");};function App() { return hello ssr ;}export default App; 浏览器访问返回的结构 hello world hello ssr 其中关键点在于1. const root = renderToString();2. ${root}3. 通过 1和2,其实服务端已完成渲染，返回给我们html，但是我们还没有事件绑定，我们需要通过引用的脚本文件就是 hydrate(,document.getElementById(“root”))。 交给浏览器完成事件绑定。 那假如我们写成如下可以么？ 1. 2. 去掉 renderToString的root常量可以么？浏览器访问返回的html如下： hello world 此种情况下能够正常运行，但是这种情况下。生成的dom结构。通过hydrate(,document.getElementById(“root”))也交给浏览器完成。显然此种，并不利于SEO优化。我们希望返回给浏览器的是比较完整dom结构，方便浏览器引擎爬虫。 ==* hydrate 描述的是 ReactDOM 复用 ReactDOMServer 服务端渲染的内容时尽可能保留结构，并补充事件绑定等 Client 特有内容的过程==。 代码传送门","permalink":"https://tianwenju.github.io/2020/10/19/React-SSR-%E5%90%8C%E6%9E%84%E6%B8%B2%E6%9F%93/","photos":["http://5b0988e595225.cdn.sohucs.com/images/20190919/745b23c1ac124d31a8b4af5cc8134b89.jpeg"]},{"tags":[{"name":"Material-Ui","slug":"Material-Ui","permalink":"https://tianwenju.github.io/tags/Material-Ui/"}],"title":"Material-Ui 响应式布局","date":"2020/04/14","text":"简介它是React组件，实现了谷歌Material Design设计规范。世界上最流行的React界面框架。 支持平台Material-UI支持所有主流的稳定的浏览器，支持IE11以上。Material-UI还支持node.js v6.x以上的服务端渲染。 响应式UI Material-UI布局，使用统一的组件和间距，实现了多平台、多环境和屏幕尺寸的统一性 Grid 组件 Material-UI的响应式UI，是基于12列的栅格布局。Material-UI的栅格系统是由 Grid 组件实现的，它使用了 CSS 弹性盒模型，它有两种类型的布局，分别是 containers 和 items。item的宽度被设置为百分比，因此它们总是基于父元素而流动、动态地变换大小。items使用内边距padding生成元素之间的间距空间。 Material-UI栅格系统支持五种断点模式，分别是 xs / sm / md / lg / xl 。每个断点（一个键）匹配一个固定的屏幕宽度（一个值）： 1. xs, 特别小的屏幕，0px or larger2. sm, 小屏幕，600px or larger3. md, 中等屏幕，960px or larger4. lg, 大屏幕， 1280px or larger5. xl, 超大屏幕， 1920px or largervalue |0px 600px 960px 1280px 1920pxkey |xs sm md lg xlscreen width |--------|--------|--------|--------|-------->range | xs | sm | md | lg | xl Hidden Hidden组件用于隐藏任何内容，它可以结合Grid / Breakpoints组件一起使用。它的实现原理是，基于breakpoints进行显示与隐藏。 示例 xsUp smUp mdUp lgUp xlUp Breakpoints 组件 一个 breakpoint 就是一组预定义的屏幕尺寸范围，它决定了特定了布局需求。为了最适宜的用户体验，material design要实现多屏幕适配。Material-UI对material design规范进行了简化实现。每一个breakpoint都会匹配一定范围的屏幕尺寸。 1. xs, 特别小的屏幕，0px or larger2. sm, 小屏幕，600px or larger3. md, 中等屏幕，960px or larger4. lg, 大屏幕， 1280px or larger5. xl, 超大屏幕， 1920px or largervalue |0px 600px 960px 1280px 1920pxkey |xs sm md lg xlscreen width |--------|--------|--------|--------|-------->range | xs | sm | md | lg | xl 这些值可以自定义。 这些值被用于主题设定，你可以在 breakpoints.values 对象上找到它们。 定义断点const values = { xs: 0, sm: 600, md: 960, lg: 1280, xl: 1920,};const theme = { breakpoints: { keys: ['xs', 'sm', 'md', 'lg', 'xl'], up: key => `@media (min-width:${values[key]}px)`, },}; CSS媒体查询CSS媒体查询是使UI响应的惯用方法。该主题提供了四种样式助手 theme.breakpoints.up(key) theme.breakpoints.down(key) theme.breakpoints.only(key) theme.breakpoints.between(start, end)const styles = theme => ({ root: { padding: theme.spacing(1), [theme.breakpoints.down('sm')]: { backgroundColor: theme.palette.secondary.main, }, [theme.breakpoints.up('md')]: { backgroundColor: theme.palette.primary.main, }, [theme.breakpoints.up('lg')]: { backgroundColor: green[500], }, },}); JavaScript媒体查询有时, 使用 CSS 是不够的。 您可能希望基于 JavaScript 中的断点值更改 React 渲染树。useMediaQuery 这是React的CSS媒体查询钩子。 它侦听与CSS媒体查询的匹配。 它允许根据查询是否匹配来呈现组件。import React from 'react';import useMediaQuery from '@material-ui/core/useMediaQuery';export default function SimpleMediaQuery() { const matches = useMediaQuery('(min-width:600px)'); return {`(min-width:600px) matches: ${matches}`};} withWidth() 高级组件import withWidth from '@material-ui/core/withWidth';function MyComponent(props) { return {`Current width: ${props.width}`};}export default withWidth()(MyComponent);","permalink":"https://tianwenju.github.io/2020/04/14/material-ui-responsive/","photos":[]},{"tags":[{"name":"内网穿透","slug":"内网穿透","permalink":"https://tianwenju.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"}],"title":"基于小米球的内网穿透","date":"2020/04/09","text":"基于小米球的内网穿透 需求场景 需要免费内网穿透服务 管理内网服务器，内网web进行演示 快速开发微信程序和第三方支付平台调试小米球简介 ngrok 服务可以分配给你一个域名让你本地的web项目提供给外网访问，特别适合向别人展示你本机的web demo 以及调试一些远程的API (比如微信公众号，企业号的开发) ngrok的官方服务可以在 这里查看 由于一些原因 有些同学可能打不开官方网站，国内访问不了，万幸的是ngrok 1.7版本的代码是开源的。 小米球就是基于ngrok的服务（小米球ngrok），来造福开发者。 为什么不直接使用ngrok？所用的服务器为美国服务器，会比较卡顿。 准备 注册一个小米球账号，获取免费的Token 在后台首页下载对应版本客户端 将下载的压缩文件解压 修改配置 ngrok.conf 属性名 解释 auth_token 换成注册从后获取的Token subdomain 外网访问的域名前缀,最好写一个不容易被别人重复的 httpstun 隧道名称 可以自定义 http https 协议 server_addr: \"ngrok2.xiaomiqiu.cn:5432\"trust_host_root_certs: trueinspect_addr: disabledauth_token: \"2994ecZ4345249f7bAA94949889c82Ac\"tunnels: httptun: remote_port: 80 subdomain: my-test proto: http: 127.0.0.1:8088 httpstun: remote_port: 443 subdomain: my-test proto: https: 127.0.0.1:8080 tcptun: remote_port: 81 proto: tcp: 127.0.0.1:81 如果打开ngrok.conf发现格式是乱的，请尝试用其他文本工具(如:Editplus、Notepad++)打开试试!重新修正~ 启动命令linux 和MAC 如下 1、chmod +x ngrok2、chmod +x ngrok.conf3、./ngrok -log=ngrok.log -config ngrok.conf start httptun httpstun 执行结果如下：浏览器输入 http://my-test.ngrok2.xiaomiqiu.cn就是我们外网地址。","permalink":"https://tianwenju.github.io/2020/04/09/XiaoMiQiu/","photos":["http://ngrok.ciqiuwl.cn/img/ngrok_p.jpg"]},{"tags":[{"name":"web-server","slug":"web-server","permalink":"https://tianwenju.github.io/tags/web-server/"}],"title":"Nestjs-01","date":"2020/04/09","text":"NestJS-01 NestJS 介绍 Nest 是一个渐进的 Node.js 框架，可以在 TypeScript 和 JavaScript (ES6、ES7、ES8)之上构 建高效、可伸缩的企业级服务器端应用程序。 Nest 基于 TypeScript 编写并且结合了 OOP（面向对象编程），FP（函数式编程）和 FRP （函数式响应编程）的相关理念。在设计上的很多灵感来自于 Angular，Angular 的很多模 式又来自于 Java 中的 Spring 框架，依赖注入、面向切面编程等，所以我们也可以认为： Nest 是 Node.js 版的 Spring 框架。 Nest 框架底层 HTTP 平台默认是基于 Express 实现的，所以无需担心第三方库的缺失。Nest 旨在成为一个与平台无关的框架.通过平台，可以创建可重用的逻辑部件，开发人员可以利用这些部件来跨越多种不同类型的应用程序。 从技术上讲，Nest 可以在创建适配器 后使用任何 Node HTTP 框架。 有两个支持开箱即用的 HTTP 平台：express 和 fastify。 您 可以选择最适合您需求的产品。 NestJS 的核心思想：就是提供了一个层与层直接的耦合度极小,抽象化极高的一个架构体系 NestJS和Egg.js的简单对比 Egg.js 是和 Nest.js 都是为企业级框架和应用而生。 Egg.js 和 Nest.js 都是非常优秀的 Nodejs 框架。Egg.js 基于 Koa，Nest.js 默认基于 Express，nest 也可以基于其他框架 Egg.js 文档相比 NestJS 优秀很多 Express、Koa 是 Node.js 社区广泛使用的框架，简单且扩展性强，非常适合做个 人项目。但框架本身缺少约定，标准的 MVC 模型会有各种千奇百怪的写法。Egg 和 NestJS 都是按照约定进行开发的。但是 Egg 相比 NestJS 约定更标准。 面向对象方面 NestJS 优于 Egg.js，NestJS 基于 TypeScript，如果你会 angular 或者 java 学习 NestJS 非常容易。 Egg.js 的特性： 提供基于 Egg 定制上层框架的能力 高度可扩展的插件机制 内置多进程管理 基于 Koa 开发，性能优异 框架稳定，测试覆盖率高 渐进式开发必备基础 Nodejs Typescript ExpressNestJS 的特性： 依赖注入容器 模块化封装 可测试性 内置支持 TypeScript 可基于 Express 或者 fastifyNestJS环境搭建及运行 官网：https://nestjs.com/ 中文网站：https://docs.nestjs.cn/ GitHub: https://github.com/nestjs/nest","permalink":"https://tianwenju.github.io/2020/04/09/NestJs01/","photos":["https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1020128022","1175558782&fm=26&gp=0.jpg"]},{"tags":[{"name":"修饰器","slug":"修饰器","permalink":"https://tianwenju.github.io/tags/%E4%BF%AE%E9%A5%B0%E5%99%A8/"}],"title":"TypeScript修饰器","date":"2020/04/08","text":"类装饰器 无参数 类装饰器表达式在运行时作为函数被调用时候,类的构造函数作为其唯一的参数 如果类的装饰器返回一个值，它会使用提供的构造函数来替换类的声明 function logClasss(target:any){ console.log(target); // 构造函数 return class extends target{ apiUrl:any='我是修改后的数据'; getData(){ this.apiUrl=this.apiUrl+'----'; console.log(this.apiUrl); } } } @logClasssclass HttpClient{ } 有参数 参数是 传入的参数 返回的参数 target 是类的构造函数 function logClass(params:string){ return function(target:any){ console.log(\"xxx\",params); console.log(\"xxx\",target); } } 属性装饰器 params 传入的参数 target 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象 attr 是对象属性 function logProperty(params:any){ return function(target:any,attr:any){ console.log(\"000\",params) console.log(\"000\",target); console.log(\"000\",attr); target[attr]=params; }} class HttpClient111{ @logProperty('http://itying.com') public url:any |undefined; getData(){ console.log(this.url); }} 方法装饰器 它会被应用到方法的 属性描述符上，可以用来监视，修改或者替换方法定义。方法装饰会在运行时传入下列3个参数： 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。 成员的名字。 成员的属性描述符（value就是方法）。 function get(params:any){ return function(target:any,methodName:any,desc:any){ console.log(target); console.log(methodName); console.log(desc.value); // value就是当前方法 //修改装饰器的方法 把装饰器方法里面传入的所有参数改为string类型 //1、保存当前的方法 var oMethod=desc.value; desc.value=function(...args:any[]){ args=args.map((value)=>{ return String(value); }) oMethod.apply(this,args); } }} 方法属性修饰器 参数装饰器表达式会在运行时当作函数被调用，可以使用参数装饰器为类的原型增加一些元素数据 ，传入下列3个参数： 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。 方法的名字。 参数在函数参数列表中的索引。 function logParams(params:any){ return function(target:any,methodName:any,paramsIndex:any){ console.log(params); console.log(target); console.log(methodName); console.log(paramsIndex); target.apiUrl=params; } 装饰器执行顺序 属性》方法》方法参数》类 如果有多个同样的装饰器，它会先执行后面的","permalink":"https://tianwenju.github.io/2020/04/08/TypeScript%E4%BF%AE%E9%A5%B0%E5%99%A8/","photos":[]}],"categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://tianwenju.github.io/tags/React/"},{"name":"Material-Ui","slug":"Material-Ui","permalink":"https://tianwenju.github.io/tags/Material-Ui/"},{"name":"内网穿透","slug":"内网穿透","permalink":"https://tianwenju.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"name":"web-server","slug":"web-server","permalink":"https://tianwenju.github.io/tags/web-server/"},{"name":"修饰器","slug":"修饰器","permalink":"https://tianwenju.github.io/tags/%E4%BF%AE%E9%A5%B0%E5%99%A8/"}]}